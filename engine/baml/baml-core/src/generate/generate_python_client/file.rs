use log::info;
use std::io::Write;
use std::{
    collections::{HashMap, HashSet},
    path::PathBuf,
};

const TAB_SIZE: usize = 4;
const TAB: &str = "                                                                  ";

#[derive(Debug, Default)]
pub(super) struct FileCollector {
    last_file: Option<PathBuf>,
    files: HashMap<PathBuf, File>,
}

impl FileCollector {
    pub fn start_py_file<'a>(&'a mut self, path: impl AsRef<str>, name: impl AsRef<str>) {
        let cleaned_path = clean_file_name(&path);
        let cleaned_name = clean_file_name(&name);
        // Add .py to the end of the name if another extension is not already present
        let cleaned_name = if cleaned_name.ends_with(".py") || cleaned_name.ends_with(".pyi") {
            cleaned_name
        } else {
            format!("{}.py", cleaned_name)
        };
        let key = PathBuf::from(cleaned_path).join(cleaned_name);

        if self.last_file.is_some() {
            panic!(
                "File already started: {:?}. Can't start {:?}",
                self.last_file, key
            );
        }

        self.last_file = Some(key.clone());

        if self.files.contains_key(&key) {
            panic!("Rewriting file: {:?}", key);
        }

        self.files.insert(key.clone(), File::new(path, name));
    }

    pub fn complete_file<'a>(&'a mut self) {
        if self.last_file.is_none() {
            panic!("No file to complete");
        }

        self.last_file = None;
    }

    pub fn last_file(&mut self) -> &mut File {
        if self.last_file.is_none() {
            panic!("No file to complete");
        }
        self.last_file
            .as_ref()
            .and_then(|path| self.files.get_mut(path))
            .unwrap()
    }

    pub fn write(&self, output: &Option<String>) -> std::io::Result<()> {
        let comment_prefix = format!(
            r#"# This file is generated by the BAML compiler.
# Do not edit this file directly.
# Instead, edit the BAML files and recompile.
#
# BAML version: {}
# Generated Date: {}
# Generated by: {}

"#,
            env!("CARGO_PKG_VERSION"),
            chrono::Local::now(),
            whoami::username()
        );
        for file in self.files.values() {
            let path = match output {
                Some(output) => PathBuf::from(output).join(file.path()),
                None => file.path(),
            };
            std::fs::create_dir_all(path.parent().unwrap())?;
            std::fs::write(&path, &comment_prefix)?;
            std::fs::OpenOptions::new()
                .append(true)
                .open(&path)?
                .write_all(file.content().as_bytes())?;
        }
        Ok(())
    }
}

#[derive(Debug, Clone)]
pub(super) struct File {
    path: PathBuf,
    name: String,
    content: String,
    imports: HashMap<String, HashSet<String>>,
}

fn clean_file_name(name: impl AsRef<str>) -> String {
    name.as_ref()
        .to_ascii_lowercase()
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() || c == '_' || c == '/' || c == '.' {
                c
            } else {
                '_'
            }
        })
        .collect::<String>()
}

impl File {
    pub(super) fn new(path: impl AsRef<str>, name: impl AsRef<str>) -> Self {
        Self {
            path: clean_file_name(path).into(),
            name: format!("{}.py", clean_file_name(name)),
            content: String::new(),
            imports: HashMap::new(),
        }
    }

    pub(super) fn add_import(&mut self, module: &str, name: &str) {
        self.imports
            .entry(module.to_string())
            .or_default()
            .insert(name.to_string());
    }

    pub(super) fn add_line(&mut self, line: impl AsRef<str>) {
        self.add_indent_line(line, 0);
    }

    pub(super) fn add_indent_line<'a>(&mut self, line: impl AsRef<str>, indent: usize) {
        self.add_indent_string(line, indent);
        self.add_empty_line();
    }

    pub(super) fn add_indent_string(&mut self, string: impl AsRef<str>, indent: usize) {
        let num_spaces = indent * TAB_SIZE;

        let prefix = match num_spaces > TAB.len() {
            true => panic!("Indentation too large"),
            false => &TAB[..num_spaces],
        };
        // Split the string by newlines and add each line with the correct indent
        let mut lines = string.as_ref().split('\n').peekable();
        // Loop through the lines
        while let Some(line) = lines.next() {
            // Add the prefix if the line is not empty
            if !line.is_empty() {
                self.add_string(&prefix);
            }

            // Add the line itself
            self.add_string(line);

            // Add an empty line if there are more lines remaining
            if lines.peek().is_some() {
                self.add_empty_line();
            }
        }
    }

    pub(super) fn add_empty_indent(&mut self, indent: usize) {
        let num_spaces = indent * TAB_SIZE;

        let prefix = match num_spaces > TAB.len() {
            true => panic!("Indentation too large"),
            false => &TAB[..num_spaces],
        };
        self.add_string(&prefix);
    }

    pub(super) fn add_empty_line(&mut self) {
        self.content.push('\n');
    }

    pub(super) fn add_string(&mut self, string: impl AsRef<str>) {
        self.content.push_str(string.as_ref());
    }

    pub(super) fn path(&self) -> PathBuf {
        self.path.join(&self.name)
    }

    pub(super) fn content(&self) -> String {
        let mut buffer = self
            .imports
            .iter()
            .fold(String::new(), |mut buffer, (module, names)| {
                buffer.push_str(&format!("from {} import ", module));
                buffer.push_str(
                    &names
                        .iter()
                        .fold(String::new(), |mut buffer, name| {
                            buffer.push_str(name);
                            buffer.push_str(", ");
                            buffer
                        })
                        .trim_end_matches(", "),
                );
                buffer.push('\n');
                buffer
            });

        buffer.push_str("\n\n");
        buffer.push_str(&self.content);
        buffer
    }
}
