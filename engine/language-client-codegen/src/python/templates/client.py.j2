from typing import Dict, Generic, List, Optional, Tuple, TypeVar, Union
import pprint

import baml_py
from pydantic import BaseModel, ValidationError

from . import types

OutputType = TypeVar('OutputType')

class BamlOutputWrapper(BaseModel, Generic[OutputType]):
    wrapped: OutputType

class BamlClient:
    __runtime: baml_py.BamlRuntimeFfi

    @staticmethod
    def from_directory(path: str) -> "BamlClient":
      return BamlClient(runtime=baml_py.BamlRuntimeFfi.from_directory(path))

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    {% for fn in funcs -%}
    async def {{fn.name}}(
        self,
        {% for (name, type) in fn.args -%}
        {{name}}: {{type}}{% if !loop.last %},{% endif %}
        {%- endfor %}
    ) -> {{fn.return_type}}:
      raw = await self.__runtime.call_function(
        "{{fn.name}}",
        {
          {% for (name, _) in fn.args -%}
          "{{name}}": {{name}},
          {%- endfor %}
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[{{ fn.return_type }}].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for {{fn.name}}:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    {% endfor %}