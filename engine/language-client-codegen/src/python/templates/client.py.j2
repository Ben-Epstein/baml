from typing import Any, Dict, Generic, List, Optional, Tuple, TypeVar, Union
import pprint

import baml_py
from pydantic import BaseModel, ValidationError

from . import types

OutputType = TypeVar('OutputType')

class BamlOutputWrapper(BaseModel, Generic[OutputType]):
    wrapped: OutputType
    
    @classmethod
    def coerce(cls, fn_name: str, parsed: Any) -> OutputType:
      try:
        return cls.model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while casting the output type of {}:\n{}".format(
            fn_name,
            pprint.pformat(parsed)
          )
        ) from e

{% for fn in funcs -%}
class BamlOutput_{{fn.name}}:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        {% for (name, type) in fn.args -%}
        {{name}}: {{type}}{% if !loop.last %},{% endif %}
        {%- endfor %}
    ) -> {{fn.return_type}}:
      raw = await self.__runtime.call_function(
        "{{fn.name}}",
        {
          {% for (name, _) in fn.args -%}
          "{{name}}": {{name}},
          {%- endfor %}
        },
        ctx={}
      )
      return BamlOutputWrapper[{{ fn.return_type }}].coerce("{{fn.name}}", raw.parsed())

    async def unstable(
        self,
        {% for (name, type) in fn.args -%}
        {{name}}: {{type}}{% if !loop.last %},{% endif %}
        {%- endfor %}
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "{{fn.name}}",
        {
          {% for (name, _) in fn.args -%}
          "{{name}}": {{name}},
          {%- endfor %}
        },
        ctx={}
      )

{% endfor %}

class BamlClient:
    __runtime: baml_py.BamlRuntimeFfi
    {%- for fn in funcs %}
    {{fn.name}}: BamlOutput_{{fn.name}}
    {%- endfor %}

    @staticmethod
    def from_directory(path: str) -> "BamlClient":
      return BamlClient(runtime=baml_py.BamlRuntimeFfi.from_directory(path))

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime
      {%- for fn in funcs %}
      self.{{fn.name}} = BamlOutput_{{fn.name}}(self.__runtime)
      {%- endfor %}

    {% for fn in funcs %}
    async def {{ fn.name }}(
        self,
        {% for (name, type) in fn.args -%}
        {{name}}: {{type}}{% if !loop.last %},{% endif %}
        {%- endfor %}
    ) -> {{fn.return_type}}:
      raw = await self.__runtime.call_function(
        "{{fn.name}}",
        {
          {% for (name, _) in fn.args -%}
          "{{name}}": {{name}},
          {%- endfor %}
        },
        ctx={}
      )
      return BamlOutputWrapper[{{ fn.return_type }}].coerce("{{fn.name}}", raw.parsed())
    {% endfor %}