import { BamlRuntimeFfi, FunctionResult } from "@boundaryml/baml"
import types from "./types"

export class BamlClient {
  private _runtime: BamlRuntimeFfi
  private _unstableClient: BamlUnstableClient

  static fromDirectory(path: string): BamlClient {
    return new BamlClient(BamlRuntimeFfi.fromDirectory(path))
  }

  constructor(private _runtime: BamlRuntimeFfi) {
    this._unstableClient = new UnstableBamlClient(this._runtime)
  }

  get unstable(): UnstableBamlClient { return this._unstableClient; }

{% for fn in funcs %}
  {{fn.name}} = async (args: {
    {%- for (name, type) in fn.args %}
    {{name}}: {{type}},
    {%- endfor %}
  }): {{fn.return_type}} => {
    const raw = await this._runtime.callFunction("{{fn.name}}", args, {})
    return raw.parsed as {{fn.return_type}}
  }
{% endfor %}
}

export class UnstableBamlClient {
  constructor(private _runtime: BamlRuntimeFfi) {}

{% for fn in funcs %}
  {{fn.name}} = async (args: {
    {%- for (name, type) in fn.args %}
    {{name}}: {{type}},
    {%- endfor %}
  }): FunctionResult => {
    return this._runtime.callFunction("{{fn.name}}", args, {})
  }
{% endfor %}
}

{# uncomment when we implement streaming
export class BamlStreamClient {
  constructor(private _runtime: BamlRuntimeFfi) {}

{% for fn in funcs %}
  {{fn.name}} = async function* (args: {
    {%- for (name, type) in fn.args %}
    {{name}}: {{type}},
    {%- endfor %}
  }): {{fn.return_type}} {
    const stream = this._runtime.callStream("{{fn.name}}", args, {})
    for await (const raw of stream) {
      yield UNSUPPORTED_DO_NOT_SHIP_type_cast<{{fn.return_type}}>(raw.parsed)
    }
  }
{% endfor %}
}
#}
