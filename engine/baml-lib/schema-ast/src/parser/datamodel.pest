schema = {
    SOI ~ (class_enum | block_declaration | old_function_declaration | template_declaration  | type_alias | arbitrary_block | comment_block | raw_string_literal | empty_lines | CATCH_ALL)* ~ EOI
}

// a block definition without a keyword. Is not valid. Just acts as a catch for the parser to display a nice error.
arbitrary_block = { identifier ~ BLOCK_OPEN ~ ((!BLOCK_CLOSE ~ ANY) | NEWLINE)* ~ BLOCK_CLOSE }

// ######################################
// Unified Block for Class and Enum
// ######################################
class_enum_keyword = { ENUM_KEYWORD | CLASS_KEYWORD } 
class_enum = { class_enum_keyword ~ identifier ~ named_argument_list? ~ BLOCK_OPEN ~ class_enum_contents ~ BLOCK_CLOSE }
class_enum_contents = { (class_enum_declaration | block_attribute | comment_block | empty_lines | BLOCK_LEVEL_CATCH_ALL)+ }
class_enum_declaration = {
    identifier ~ field_type_chain ~ (NEWLINE? ~ field_attribute)* ~ NEWLINE 
  | key_value ~ NEWLINE
}

field_operator = { "|" | "&" }
field_type_chain = { field_type_with_attr ~ (field_operator ~ field_type_with_attr)* }
field_type_with_attr = { field_type ~ (NEWLINE? ~ field_attribute)* }

// ######################################
// Unified Block for Function, Test, Client, Generator
// ######################################
block_keyword = { FUNCTION_KEYWORD | TEST_KEYWORD | CLIENT_KEYWORD | GENERATOR_KEYWORD }
block_declaration = { block_keyword ~ identifier ~ named_argument_list? ~ ARROW? ~ field_type? ~ SPACER_TEXT ~ BLOCK_OPEN ~ block_contents ~ BLOCK_CLOSE }
block_contents = {
    (key_value | (field_attribute ~ NEWLINE?)+ | comment_block | empty_lines | BLOCK_LEVEL_CATCH_ALL)*
}
// ######################################
ARROW = { SPACER_TEXT ~ "->" ~ SPACER_TEXT }


// ######################################
// Template Declaration
// ######################################
assignment = { "=" }
template_declaration = { TEMPLATE_KEYWORD ~ identifier ~ assignment? ~ named_argument_list? ~ raw_string_literal }


colon          = { ":" }
named_argument = { identifier ~ ((":" ~ field_type) | colon)? }
// Be forgiving and allow trailing comma
named_argument_list = { "(" ~ SPACER_TEXT ~ named_argument? ~ ("," ~ SPACER_TEXT ~ named_argument)* ~ ","? ~ SPACER_TEXT ~ ")" }

key_value = { identifier ~ template_args? ~ expression? ~ (NEWLINE? ~ field_attribute)* ~ trailing_comment? }


// ######################################
// Attributes
// ######################################
block_attribute = { "@@" ~ identifier ~ arguments_list? }
field_attribute = { "@" ~ identifier ~ arguments_list? }


// Pest is greedy, order is very important here.
field_type = { (union | non_union) ~ optional_token? }
optional_token = { "?" }
union = { base_type_with_attr ~ (field_operator ~ base_type_with_attr)* }
base_type_with_attr = { base_type ~ (NEWLINE? ~ field_attribute)* }
base_type = { array_notation | map | identifier | group | tuple | parenthesized_type }

array_suffix = { "[]" }
array_notation = { base_type_without_array ~ array_suffix+ }

map = { "map" ~ "<" ~ field_type ~ "," ~ field_type ~ ">" }
group = { "(" ~ field_type ~ ")" }
tuple = { "(" ~ field_type ~ ("," ~ field_type)+ ~ ")" }

base_type_without_array = { map | identifier | group | tuple }

non_union = { array_notation | map | identifier | group | tuple }

parenthesized_type = { "(" ~ field_type_with_attr ~ ")" }

path_identifier =  { single_word ~ ("." ~ single_word)+ }
identifier      =  { path_identifier | single_word }
single_word     = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "-")* }

// ######################################
// Type Alias
// ######################################
type_alias = { TYPE_KEYWORD ~ identifier ~ base_type ~ (NEWLINE? ~ field_attribute)* }

// ######################################
// Arguments
// ######################################
arguments_list = { "(" ~ (NEWLINE?) ~ expression? ~ ("," ~ (NEWLINE?) ~ expression)? ~ (NEWLINE?) ~ ")" }

// ######################################
// Expressions & Functions
// ######################################
map_key          =  { identifier | quoted_string_literal }
map_entry        =  { (comment_block | empty_lines)* ~ map_key ~ expression ~ trailing_comment? }
splitter         = _{ ("," ~ NEWLINE?) | NEWLINE }
map_expression   =  { "{" ~ empty_lines? ~ (map_entry ~ (splitter ~ map_entry)*)? ~ (comment_block | empty_lines)* ~ "}" }
array_expression =  { "[" ~ empty_lines? ~ (expression ~ trailing_comment? ~ (splitter ~ (comment_block | empty_lines)* ~ expression ~ trailing_comment?)*)? ~ (comment_block | empty_lines)* ~ "]" }
expression       =  { map_expression | array_expression | numeric_literal | string_literal | identifier }

// ######################################
// Literals / Values
// ######################################
numeric_literal = @{ ("-")? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }

// ######################################
// String literals. These behave specially in BAML.
// ######################################
banned_chars            = @{ "#" | "@" | "{" | "(" | "[" | "<" | "}" | ")" | "]" | ">" | "," | "'" | NEWLINE }
banned_start_chars      =  { WHITESPACE | banned_chars }
banned_end_chars        =  { WHITESPACE | banned_chars }
unquoted_string_literal =  { (!banned_start_chars ~ ANY) ~ (!banned_chars ~ ANY)* ~ (!banned_end_chars ~ ANY)* }
quoted_string_content   = @{ (!"\"" ~ !NEWLINE ~ ANY)* }
quoted_string_literal   = ${ "\"" ~ quoted_string_content ~ "\"" }
// TODO: Support comments in raw string literals
// TODO: Support comments in raw string literals
raw_string_literal_content = @{ (!("\"" ~ "#"*) ~ ANY)* }

raw_string_start = _{ (single_word)? ~ "#"* ~ "\"" }
raw_string_end = _{ "\"" ~ "#"* }

raw_string_literal = {
    raw_string_start ~ raw_string_literal_content ~ raw_string_end
}

unterminated_raw_string_literal = ${ raw_string_start ~ raw_string_literal_content }
unterminated_quoted_string_literal = ${ "\"" ~ quoted_string_content }
unterminated_string_literal        = ${ unterminated_raw_string_literal | unterminated_quoted_string_literal }
string_literal                     =  { raw_string_literal | quoted_string_literal | unquoted_string_literal | unterminated_string_literal }


// ######################################
// Comments and Documentation Comments
// ######################################
comment_block    = ${ ((block_comment | doc_comment | comment) ~ NEWLINE?)+ }
trailing_comment = ${ doc_comment | comment }
doc_comment      =  { WHITESPACE* ~ "///" ~ doc_content }
comment          =  { WHITESPACE* ~ (!"///") ~ "//" ~ doc_content }
block_content    = @{ (!"//}" ~ ANY)* }
block_comment    =  { WHITESPACE* ~ "{//" ~ block_content ~ "//}" }
doc_content      = @{ (!NEWLINE ~ ANY)* }

// ######################################
// Shared Building Blocks and Comments
// ######################################
WHITESPACE  = _{ " " | "\t" }
NEWLINE     = _{ "\n" | "\r\n" | "\r" }
empty_lines = @{ (WHITESPACE* ~ NEWLINE)+ }

// ######################################
// Utilities
// ######################################
SPACER_TEXT = { (comment_block | empty_lines)* }

// the any part is to not crash on comments next to an open block, see test `parse_comments_without_crasing_or_loosing_info`
BLOCK_OPEN  = { "{" }
BLOCK_CLOSE = { "}" }

BLOCK_LEVEL_CATCH_ALL = { !BLOCK_CLOSE ~ CATCH_ALL }
CATCH_ALL             = { (!NEWLINE ~ ANY)+ ~ NEWLINE? }

TYPE_KEYWORD     = { "type" }
ENUM_KEYWORD     = { "enum" }
CLASS_KEYWORD    = { "class" }
FUNCTION_KEYWORD = { "function" }
TEMPLATE_KEYWORD = { "template_string" | "string_template" }
TEST_KEYWORD     = { "test" }
CLIENT_KEYWORD       = { "client" }
GENERATOR_KEYWORD    = { "generator" }

empty_template_args = ${ "<" ~ ">" }
template_args       =  { empty_template_args | ("<" ~ expression ~ ("," ~ expression)* ~ ">") }


// ######################################
// Old Function Declaration
// ######################################
old_function_declaration = { FUNCTION_KEYWORD ~ identifier ~ BLOCK_OPEN ~ old_function_contents ~ BLOCK_CLOSE }
input_field_declaration = { "input" ~ function_field_type? ~ trailing_comment? ~ NEWLINE }
output_field_declaration = { "output" ~ function_field_type? ~ trailing_comment? ~ NEWLINE }
function_field_type = { field_type | named_argument_list }
old_function_contents = { (input_field_declaration | output_field_declaration | (key_value ~ NEWLINE) | (block_attribute ~ NEWLINE) | comment_block | empty_lines | BLOCK_LEVEL_CATCH_ALL)* }
