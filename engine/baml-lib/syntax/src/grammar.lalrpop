grammar(
    src_file: &SourceFile, // TODO: Replace this with a src_id.
);

use crate::forms::class::{Class, Field};
use crate::pos::{mk_pos, empty_pos, WithPos};
use crate::forms::identifier::Identifier;
use crate::forms::r#type::{Type, BuiltinType};

use internal_baml_diagnostics::{DatamodelError, Diagnostics, SourceFile, Span};

use std::str::FromStr;


WithPos<Rule>: Rule = <l: @L> <t: Rule> <r: @R> => t.with_pos(mk_pos(src_file, l, r));

pub Identifier: Identifier<Span> = WithPos<BareIdentifier>;

BareIdentifier: Identifier<Span> = {
    <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => {
        Identifier{name: s.to_string(), meta: empty_pos(src_file)}
    }
};


// The syntax for a Class definition.
//
// ```baml
// class Foo {
//   foo int
//   bar string[]
// }
// ```
pub Class: Class<Span> = {
    <l: @L> "class" <name:Identifier> "{" <fields:FieldList> "}" <r: @R> => {
        let span = mk_pos(src_file, l,r);
        Class {
            name,
            fields,
            meta: span,
        }
    }
};

FieldList: Vec<Field<Span>> = {
    <fields:Field> => vec![fields],
    <mut fields:FieldList> <field:Field> => {
        fields.push(field);
        fields
    }
};

Field: Field<Span> = {
    <l: @L> <name:Identifier> <type_:Type> <r: @R> => {
        let span = mk_pos(src_file, l, r);
        Field {
            name,
            r#type: type_,
            meta: span,
        }
    }
};

pub Type: Type<Span> = WithPos<BareType>;
pub BareType: Type<Span> = {
    <base:Identifier> => match BuiltinType::from_str(base.to_string().as_str()) {
        Ok(builtin_type) => Type::Builtin { builtin_type, meta: empty_pos(src_file) },
        Err(_) => Type::UserDefined { name: base }
    },
    <base:Type> "[" "]" => {
        Type::List { base_type: Box::new(base), meta: empty_pos(src_file) }
    }
};

