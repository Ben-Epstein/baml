grammar(
    src_file: &SourceFile, // TODO: Replace this with a src_id.
);

use crate::forms::class::{Class, Field};
use crate::pos::{mk_pos, empty_pos, WithPos};
use crate::forms::identifier::Identifier;
use internal_baml_diagnostics::{DatamodelError, Diagnostics, SourceFile, Span};


WithPos<Rule>: Rule = <l: @L> <t: Rule> <r: @R> => t.with_pos(mk_pos(src_file, l, r));

pub Identifier: Identifier<Span> = WithPos<BareIdentifier>;

BareIdentifier: Identifier<Span> = {
    <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => {
        Identifier{name: s.to_string(), meta: empty_pos(src_file)}
    }
};


// The syntax for a Class definition.
//
// ```baml
// class Foo {
//   foo int
//   bar string[]
// }
// ```
pub Class: Class<Span> = {
    <l: @L> "class" <name:Identifier> "{" <fields:FieldList> "}" <r: @R> => {
        let span = mk_pos(src_file, l,r);
        Class {
            name,
            fields,
            meta: span,
        }
    }
};

FieldList: Vec<Field<Span>> = {
    <fields:Field> => vec![fields],
    <mut fields:FieldList> <field:Field> => {
        fields.push(field);
        fields
    }
};

Field: Field<Span> = {
    <l: @L> <name:Identifier> <type_:Type> <r: @R> => {
        let span = mk_pos(src_file, l, r);
        Field {
            name,
            r#type: type_,
            meta: span,
        }
    }
};

pub Type: Type<Span> = WithPos<BareType>;
pub BareType: Type<Span> = {
    <base:Identifier> => Type::Builtin {
      builtin_type: BuiltinType::from_str(base).unwrap(),
      meta: empty_pos()
    },
    <base:Identifier> "[" "]" => {
        let mut type_name = base.clone();
        type_name.name.push_str("[]");
        type_name
    }
};

