// BAML function signature
{{#if params.positional}}
type I{{name}} = ({{params.name}}: {{params.type}}) => Promise<{{return_type}}>
{{else}}
type I{{name}} = ({{params.name}}: {
  {{#each params.values as |v|}}{{v.name}}: {{v.type}}, {{/each}}
}) => Promise<{{return_type}}>
{{/if}}

// BAML function stream signature
{{#if params.positional}}
type I{{name}}Stream = ({{params.name}}: {{params.type}}) => LLMResponseStream<{{return_type}}>
{{else}}
type I{{name}}Stream = ({{params.name}}: {
  {{#each params.values as |v|}}{{v.name}}: {{v.type}}, {{/each}}
}) => Promise<{{return_type}}>
{{/if}}

{{#if impls}}
type {{name}}ImplKey = {{#each impls as |impl|}}{{#if @first}}'{{impl}}'{{else}} | '{{impl}}'{{/if}}{{/each}};
{{else}}
type {{name}}ImplKey = never;
{{/if}}

interface {{name}}Impl {
    name: {{name}}ImplKey;
    run: I{{name}};
    stream: I{{name}}Stream;
}

interface {{name}}Function {
  stream: I{{name}}Stream;
  registerImpl: (name: {{name}}ImplKey, cb: I{{name}}, stream_cb: I{{name}}Stream) => void;
  getImpl: (name: {{name}}ImplKey) => {{name}}Impl;
}

function create{{name}}Instance(): I{{name}} & {{name}}Function {

  const registry: Record<{{name}}ImplKey, {{name}}Impl> = {}

  const wrapper: {{name}}Function = {
    getImpl: (name: {{name}}ImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for {{name}} with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: {{name}}ImplKey, cb: I{{name}}, stream_cb: I{{name}}Stream) => {
      if (registry[name]) {
        throw new Error(`Implementation for {{name}} with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"{{name}}",
          /* returnType */ "{{return_type}}",
          /* paramters */ [
            {{#if params.positional}}
            [
              "{{params.name}}",
              "{{params.type}}"
            ]
            {{else}}
            {{#each params.values as |v|}}
            [
              "{{v.name}}",
              "{{v.type}}"
            ]{{#unless @last}},{{/unless}}
            {{/each}}
            {{/if}}
          ],
          /* arg_type */ {{#if params.positional}}'positional'{{else}}'named'{{/if}},
          /* cb */ async (
          {{#if params.positional}}
          {{params.name}}: {{params.type}}
          {{else}}
          params: {
            {{#each params.values as |v|}}{{v.name}}: {{v.type}}{{#unless @last}}, {{/unless}}{{/each}}
          }
          {{/if}}
        ) => {
          FireBamlEvent.variant(name);
          return await cb({{#if params.positional}}{{params.name}}{{else}}params{{/if}});
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      {{#if impls}}
      const targets = [{{#each impls as |impl|}}'{{impl}}'{{#unless @last}}, {{/unless}}{{/each}}];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for {{name}}: ${missing.join(', ')}`);
      }
      {{/if}}
    }
  };

  {{#if params.positional}}
  const impl = async ({{params.name}}: {{params.type}}) => {
  {{else}}
  const impl = async (params : {
    {{#each params.values as |v|}}{{v.name}}: {{v.type}}{{#unless @last}}, {{/unless}}{{/each}}
  }) => {
  {{/if}}
    {{#if default_impl}}
    return wrapper.getImpl('{{default_impl}}').run({{#if params.positional}}{{params.name}}{{else}}params{{/if}});
    {{else}}
    throw new Error('No implementation for {{name}}');
    {{/if}}
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: ({{#if params.positional}}{{params.name}}{{else}}params{{/if}}) => {
      {{#if default_impl}}
      return wrapper.getImpl('{{default_impl}}').stream({{#if params.positional}}{{params.name}}{{else}}params{{/if}});
      {{else}}
      throw new Error('No implementation for {{name}}');
      {{/if}}
    }
  })

  return impl as I{{name}} & {{name}}Function;
}

const {{name}} = create{{name}}Instance();
