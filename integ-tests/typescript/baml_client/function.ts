// This file is auto-generated. Do not edit this file manually.
//
// Disable formatting for this file to avoid linting errors.
// tslint:disable
// @ts-nocheck
/* eslint-disable */


import { ClassOptionalFields, ClassOptionalOutput, ClassOptionalOutput2, EnumOutput, NamedArgsSingleClass, NamedArgsSingleEnum, NamedArgsSingleEnumList, OptionalClass, OptionalTest_ReturnType, OverrideClass, OverrideEnum, TestClassAlias, TestClassWithEnum, TestEnum, TestOutputClass, UnionTest_ReturnType } from './types';
import { LLMResponseStream } from '@boundaryml/baml-core';
import { FireBamlEvent, traceAsync } from '@boundaryml/baml-core/ffi_layer';


// BAML function signature
type IFnClassOptional = (arg: OptionalClass | null) => Promise<string>

// BAML function stream signature
type IFnClassOptionalStream = (arg: OptionalClass | null) => LLMResponseStream<string>

type FnClassOptionalImplKey = 'v1';

interface FnClassOptionalImpl {
    name: FnClassOptionalImplKey;
    run: IFnClassOptional;
    stream: IFnClassOptionalStream;
}

interface FnClassOptionalFunction {
  stream: IFnClassOptionalStream;
  registerImpl: (name: FnClassOptionalImplKey, cb: IFnClassOptional, stream_cb: IFnClassOptionalStream) => void;
  getImpl: (name: FnClassOptionalImplKey) => FnClassOptionalImpl;
}

function createFnClassOptionalInstance(): IFnClassOptional & FnClassOptionalFunction {

  const registry: Record<FnClassOptionalImplKey, FnClassOptionalImpl> = {}

  const wrapper: FnClassOptionalFunction = {
    getImpl: (name: FnClassOptionalImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalImplKey, cb: IFnClassOptional, stream_cb: IFnClassOptionalStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "OptionalClass | null"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: OptionalClass | null
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: OptionalClass | null) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnClassOptional & FnClassOptionalFunction;
}

const FnClassOptional = createFnClassOptionalInstance();

// BAML function signature
type IFnClassOptional2 = (arg: ClassOptionalFields) => Promise<string>

// BAML function stream signature
type IFnClassOptional2Stream = (arg: ClassOptionalFields) => LLMResponseStream<string>

type FnClassOptional2ImplKey = 'v1';

interface FnClassOptional2Impl {
    name: FnClassOptional2ImplKey;
    run: IFnClassOptional2;
    stream: IFnClassOptional2Stream;
}

interface FnClassOptional2Function {
  stream: IFnClassOptional2Stream;
  registerImpl: (name: FnClassOptional2ImplKey, cb: IFnClassOptional2, stream_cb: IFnClassOptional2Stream) => void;
  getImpl: (name: FnClassOptional2ImplKey) => FnClassOptional2Impl;
}

function createFnClassOptional2Instance(): IFnClassOptional2 & FnClassOptional2Function {

  const registry: Record<FnClassOptional2ImplKey, FnClassOptional2Impl> = {}

  const wrapper: FnClassOptional2Function = {
    getImpl: (name: FnClassOptional2ImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptional2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptional2ImplKey, cb: IFnClassOptional2, stream_cb: IFnClassOptional2Stream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptional2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptional2",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "ClassOptionalFields"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: ClassOptionalFields
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptional2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: ClassOptionalFields) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnClassOptional2 & FnClassOptional2Function;
}

const FnClassOptional2 = createFnClassOptional2Instance();

// BAML function signature
type IFnClassOptionalOutput = (arg: string) => Promise<ClassOptionalOutput | null>

// BAML function stream signature
type IFnClassOptionalOutputStream = (arg: string) => LLMResponseStream<ClassOptionalOutput | null>

type FnClassOptionalOutputImplKey = 'v1';

interface FnClassOptionalOutputImpl {
    name: FnClassOptionalOutputImplKey;
    run: IFnClassOptionalOutput;
    stream: IFnClassOptionalOutputStream;
}

interface FnClassOptionalOutputFunction {
  stream: IFnClassOptionalOutputStream;
  registerImpl: (name: FnClassOptionalOutputImplKey, cb: IFnClassOptionalOutput, stream_cb: IFnClassOptionalOutputStream) => void;
  getImpl: (name: FnClassOptionalOutputImplKey) => FnClassOptionalOutputImpl;
}

function createFnClassOptionalOutputInstance(): IFnClassOptionalOutput & FnClassOptionalOutputFunction {

  const registry: Record<FnClassOptionalOutputImplKey, FnClassOptionalOutputImpl> = {}

  const wrapper: FnClassOptionalOutputFunction = {
    getImpl: (name: FnClassOptionalOutputImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptionalOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalOutputImplKey, cb: IFnClassOptionalOutput, stream_cb: IFnClassOptionalOutputStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptionalOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptionalOutput",
          /* returnType */ "ClassOptionalOutput | null",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptionalOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnClassOptionalOutput & FnClassOptionalOutputFunction;
}

const FnClassOptionalOutput = createFnClassOptionalOutputInstance();

// BAML function signature
type IFnClassOptionalOutput2 = (arg: string) => Promise<ClassOptionalOutput2 | null>

// BAML function stream signature
type IFnClassOptionalOutput2Stream = (arg: string) => LLMResponseStream<ClassOptionalOutput2 | null>

type FnClassOptionalOutput2ImplKey = 'v1';

interface FnClassOptionalOutput2Impl {
    name: FnClassOptionalOutput2ImplKey;
    run: IFnClassOptionalOutput2;
    stream: IFnClassOptionalOutput2Stream;
}

interface FnClassOptionalOutput2Function {
  stream: IFnClassOptionalOutput2Stream;
  registerImpl: (name: FnClassOptionalOutput2ImplKey, cb: IFnClassOptionalOutput2, stream_cb: IFnClassOptionalOutput2Stream) => void;
  getImpl: (name: FnClassOptionalOutput2ImplKey) => FnClassOptionalOutput2Impl;
}

function createFnClassOptionalOutput2Instance(): IFnClassOptionalOutput2 & FnClassOptionalOutput2Function {

  const registry: Record<FnClassOptionalOutput2ImplKey, FnClassOptionalOutput2Impl> = {}

  const wrapper: FnClassOptionalOutput2Function = {
    getImpl: (name: FnClassOptionalOutput2ImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnClassOptionalOutput2 with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnClassOptionalOutput2ImplKey, cb: IFnClassOptionalOutput2, stream_cb: IFnClassOptionalOutput2Stream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnClassOptionalOutput2 with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnClassOptionalOutput2",
          /* returnType */ "ClassOptionalOutput2 | null",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnClassOptionalOutput2: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnClassOptionalOutput2 & FnClassOptionalOutput2Function;
}

const FnClassOptionalOutput2 = createFnClassOptionalOutput2Instance();

// BAML function signature
type IFnEnumListOutput = (arg: string) => Promise<EnumOutput[]>

// BAML function stream signature
type IFnEnumListOutputStream = (arg: string) => LLMResponseStream<EnumOutput[]>

type FnEnumListOutputImplKey = 'v1';

interface FnEnumListOutputImpl {
    name: FnEnumListOutputImplKey;
    run: IFnEnumListOutput;
    stream: IFnEnumListOutputStream;
}

interface FnEnumListOutputFunction {
  stream: IFnEnumListOutputStream;
  registerImpl: (name: FnEnumListOutputImplKey, cb: IFnEnumListOutput, stream_cb: IFnEnumListOutputStream) => void;
  getImpl: (name: FnEnumListOutputImplKey) => FnEnumListOutputImpl;
}

function createFnEnumListOutputInstance(): IFnEnumListOutput & FnEnumListOutputFunction {

  const registry: Record<FnEnumListOutputImplKey, FnEnumListOutputImpl> = {}

  const wrapper: FnEnumListOutputFunction = {
    getImpl: (name: FnEnumListOutputImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnEnumListOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnEnumListOutputImplKey, cb: IFnEnumListOutput, stream_cb: IFnEnumListOutputStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnEnumListOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnEnumListOutput",
          /* returnType */ "EnumOutput[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnEnumListOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnEnumListOutput & FnEnumListOutputFunction;
}

const FnEnumListOutput = createFnEnumListOutputInstance();

// BAML function signature
type IFnEnumOutput = (arg: string) => Promise<EnumOutput>

// BAML function stream signature
type IFnEnumOutputStream = (arg: string) => LLMResponseStream<EnumOutput>

type FnEnumOutputImplKey = 'v1';

interface FnEnumOutputImpl {
    name: FnEnumOutputImplKey;
    run: IFnEnumOutput;
    stream: IFnEnumOutputStream;
}

interface FnEnumOutputFunction {
  stream: IFnEnumOutputStream;
  registerImpl: (name: FnEnumOutputImplKey, cb: IFnEnumOutput, stream_cb: IFnEnumOutputStream) => void;
  getImpl: (name: FnEnumOutputImplKey) => FnEnumOutputImpl;
}

function createFnEnumOutputInstance(): IFnEnumOutput & FnEnumOutputFunction {

  const registry: Record<FnEnumOutputImplKey, FnEnumOutputImpl> = {}

  const wrapper: FnEnumOutputFunction = {
    getImpl: (name: FnEnumOutputImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnEnumOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnEnumOutputImplKey, cb: IFnEnumOutput, stream_cb: IFnEnumOutputStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnEnumOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnEnumOutput",
          /* returnType */ "EnumOutput",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnEnumOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnEnumOutput & FnEnumOutputFunction;
}

const FnEnumOutput = createFnEnumOutputInstance();

// BAML function signature
type IFnNamedArgsSingleStringOptional = (args: {
  myString: string | null, 
}) => Promise<string>

// BAML function stream signature
type IFnNamedArgsSingleStringOptionalStream = (args: {
  myString: string | null, 
}) => Promise<string>

type FnNamedArgsSingleStringOptionalImplKey = 'v1';

interface FnNamedArgsSingleStringOptionalImpl {
    name: FnNamedArgsSingleStringOptionalImplKey;
    run: IFnNamedArgsSingleStringOptional;
    stream: IFnNamedArgsSingleStringOptionalStream;
}

interface FnNamedArgsSingleStringOptionalFunction {
  stream: IFnNamedArgsSingleStringOptionalStream;
  registerImpl: (name: FnNamedArgsSingleStringOptionalImplKey, cb: IFnNamedArgsSingleStringOptional, stream_cb: IFnNamedArgsSingleStringOptionalStream) => void;
  getImpl: (name: FnNamedArgsSingleStringOptionalImplKey) => FnNamedArgsSingleStringOptionalImpl;
}

function createFnNamedArgsSingleStringOptionalInstance(): IFnNamedArgsSingleStringOptional & FnNamedArgsSingleStringOptionalFunction {

  const registry: Record<FnNamedArgsSingleStringOptionalImplKey, FnNamedArgsSingleStringOptionalImpl> = {}

  const wrapper: FnNamedArgsSingleStringOptionalFunction = {
    getImpl: (name: FnNamedArgsSingleStringOptionalImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnNamedArgsSingleStringOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnNamedArgsSingleStringOptionalImplKey, cb: IFnNamedArgsSingleStringOptional, stream_cb: IFnNamedArgsSingleStringOptionalStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnNamedArgsSingleStringOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnNamedArgsSingleStringOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myString",
              "string | null"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myString: string | null
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnNamedArgsSingleStringOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myString: string | null
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as IFnNamedArgsSingleStringOptional & FnNamedArgsSingleStringOptionalFunction;
}

const FnNamedArgsSingleStringOptional = createFnNamedArgsSingleStringOptionalInstance();

// BAML function signature
type IFnOutputBool = (arg: string) => Promise<boolean>

// BAML function stream signature
type IFnOutputBoolStream = (arg: string) => LLMResponseStream<boolean>

type FnOutputBoolImplKey = 'v1';

interface FnOutputBoolImpl {
    name: FnOutputBoolImplKey;
    run: IFnOutputBool;
    stream: IFnOutputBoolStream;
}

interface FnOutputBoolFunction {
  stream: IFnOutputBoolStream;
  registerImpl: (name: FnOutputBoolImplKey, cb: IFnOutputBool, stream_cb: IFnOutputBoolStream) => void;
  getImpl: (name: FnOutputBoolImplKey) => FnOutputBoolImpl;
}

function createFnOutputBoolInstance(): IFnOutputBool & FnOutputBoolFunction {

  const registry: Record<FnOutputBoolImplKey, FnOutputBoolImpl> = {}

  const wrapper: FnOutputBoolFunction = {
    getImpl: (name: FnOutputBoolImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputBool with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputBoolImplKey, cb: IFnOutputBool, stream_cb: IFnOutputBoolStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputBool with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputBool",
          /* returnType */ "boolean",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputBool: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnOutputBool & FnOutputBoolFunction;
}

const FnOutputBool = createFnOutputBoolInstance();

// BAML function signature
type IFnOutputClass = (arg: string) => Promise<TestOutputClass>

// BAML function stream signature
type IFnOutputClassStream = (arg: string) => LLMResponseStream<TestOutputClass>

type FnOutputClassImplKey = 'v1';

interface FnOutputClassImpl {
    name: FnOutputClassImplKey;
    run: IFnOutputClass;
    stream: IFnOutputClassStream;
}

interface FnOutputClassFunction {
  stream: IFnOutputClassStream;
  registerImpl: (name: FnOutputClassImplKey, cb: IFnOutputClass, stream_cb: IFnOutputClassStream) => void;
  getImpl: (name: FnOutputClassImplKey) => FnOutputClassImpl;
}

function createFnOutputClassInstance(): IFnOutputClass & FnOutputClassFunction {

  const registry: Record<FnOutputClassImplKey, FnOutputClassImpl> = {}

  const wrapper: FnOutputClassFunction = {
    getImpl: (name: FnOutputClassImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClass with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassImplKey, cb: IFnOutputClass, stream_cb: IFnOutputClassStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClass with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClass",
          /* returnType */ "TestOutputClass",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClass: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnOutputClass & FnOutputClassFunction;
}

const FnOutputClass = createFnOutputClassInstance();

// BAML function signature
type IFnOutputClassList = (arg: string) => Promise<TestOutputClass[]>

// BAML function stream signature
type IFnOutputClassListStream = (arg: string) => LLMResponseStream<TestOutputClass[]>

type FnOutputClassListImplKey = 'v1';

interface FnOutputClassListImpl {
    name: FnOutputClassListImplKey;
    run: IFnOutputClassList;
    stream: IFnOutputClassListStream;
}

interface FnOutputClassListFunction {
  stream: IFnOutputClassListStream;
  registerImpl: (name: FnOutputClassListImplKey, cb: IFnOutputClassList, stream_cb: IFnOutputClassListStream) => void;
  getImpl: (name: FnOutputClassListImplKey) => FnOutputClassListImpl;
}

function createFnOutputClassListInstance(): IFnOutputClassList & FnOutputClassListFunction {

  const registry: Record<FnOutputClassListImplKey, FnOutputClassListImpl> = {}

  const wrapper: FnOutputClassListFunction = {
    getImpl: (name: FnOutputClassListImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClassList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassListImplKey, cb: IFnOutputClassList, stream_cb: IFnOutputClassListStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClassList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClassList",
          /* returnType */ "TestOutputClass[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClassList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnOutputClassList & FnOutputClassListFunction;
}

const FnOutputClassList = createFnOutputClassListInstance();

// BAML function signature
type IFnOutputClassWithEnum = (arg: string) => Promise<TestClassWithEnum>

// BAML function stream signature
type IFnOutputClassWithEnumStream = (arg: string) => LLMResponseStream<TestClassWithEnum>

type FnOutputClassWithEnumImplKey = 'v1';

interface FnOutputClassWithEnumImpl {
    name: FnOutputClassWithEnumImplKey;
    run: IFnOutputClassWithEnum;
    stream: IFnOutputClassWithEnumStream;
}

interface FnOutputClassWithEnumFunction {
  stream: IFnOutputClassWithEnumStream;
  registerImpl: (name: FnOutputClassWithEnumImplKey, cb: IFnOutputClassWithEnum, stream_cb: IFnOutputClassWithEnumStream) => void;
  getImpl: (name: FnOutputClassWithEnumImplKey) => FnOutputClassWithEnumImpl;
}

function createFnOutputClassWithEnumInstance(): IFnOutputClassWithEnum & FnOutputClassWithEnumFunction {

  const registry: Record<FnOutputClassWithEnumImplKey, FnOutputClassWithEnumImpl> = {}

  const wrapper: FnOutputClassWithEnumFunction = {
    getImpl: (name: FnOutputClassWithEnumImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputClassWithEnum with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputClassWithEnumImplKey, cb: IFnOutputClassWithEnum, stream_cb: IFnOutputClassWithEnumStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputClassWithEnum with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputClassWithEnum",
          /* returnType */ "TestClassWithEnum",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputClassWithEnum: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnOutputClassWithEnum & FnOutputClassWithEnumFunction;
}

const FnOutputClassWithEnum = createFnOutputClassWithEnumInstance();

// BAML function signature
type IFnOutputStringList = (arg: string) => Promise<string[]>

// BAML function stream signature
type IFnOutputStringListStream = (arg: string) => LLMResponseStream<string[]>

type FnOutputStringListImplKey = 'v1';

interface FnOutputStringListImpl {
    name: FnOutputStringListImplKey;
    run: IFnOutputStringList;
    stream: IFnOutputStringListStream;
}

interface FnOutputStringListFunction {
  stream: IFnOutputStringListStream;
  registerImpl: (name: FnOutputStringListImplKey, cb: IFnOutputStringList, stream_cb: IFnOutputStringListStream) => void;
  getImpl: (name: FnOutputStringListImplKey) => FnOutputStringListImpl;
}

function createFnOutputStringListInstance(): IFnOutputStringList & FnOutputStringListFunction {

  const registry: Record<FnOutputStringListImplKey, FnOutputStringListImpl> = {}

  const wrapper: FnOutputStringListFunction = {
    getImpl: (name: FnOutputStringListImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnOutputStringList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnOutputStringListImplKey, cb: IFnOutputStringList, stream_cb: IFnOutputStringListStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnOutputStringList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnOutputStringList",
          /* returnType */ "string[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnOutputStringList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnOutputStringList & FnOutputStringListFunction;
}

const FnOutputStringList = createFnOutputStringListInstance();

// BAML function signature
type IFnStringOptional = (arg: string | null) => Promise<string>

// BAML function stream signature
type IFnStringOptionalStream = (arg: string | null) => LLMResponseStream<string>

type FnStringOptionalImplKey = 'v1';

interface FnStringOptionalImpl {
    name: FnStringOptionalImplKey;
    run: IFnStringOptional;
    stream: IFnStringOptionalStream;
}

interface FnStringOptionalFunction {
  stream: IFnStringOptionalStream;
  registerImpl: (name: FnStringOptionalImplKey, cb: IFnStringOptional, stream_cb: IFnStringOptionalStream) => void;
  getImpl: (name: FnStringOptionalImplKey) => FnStringOptionalImpl;
}

function createFnStringOptionalInstance(): IFnStringOptional & FnStringOptionalFunction {

  const registry: Record<FnStringOptionalImplKey, FnStringOptionalImpl> = {}

  const wrapper: FnStringOptionalFunction = {
    getImpl: (name: FnStringOptionalImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnStringOptional with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnStringOptionalImplKey, cb: IFnStringOptional, stream_cb: IFnStringOptionalStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnStringOptional with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnStringOptional",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "string | null"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string | null
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnStringOptional: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string | null) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnStringOptional & FnStringOptionalFunction;
}

const FnStringOptional = createFnStringOptionalInstance();

// BAML function signature
type IFnTestAliasedEnumOutput = (arg: string) => Promise<TestEnum>

// BAML function stream signature
type IFnTestAliasedEnumOutputStream = (arg: string) => LLMResponseStream<TestEnum>

type FnTestAliasedEnumOutputImplKey = 'v1';

interface FnTestAliasedEnumOutputImpl {
    name: FnTestAliasedEnumOutputImplKey;
    run: IFnTestAliasedEnumOutput;
    stream: IFnTestAliasedEnumOutputStream;
}

interface FnTestAliasedEnumOutputFunction {
  stream: IFnTestAliasedEnumOutputStream;
  registerImpl: (name: FnTestAliasedEnumOutputImplKey, cb: IFnTestAliasedEnumOutput, stream_cb: IFnTestAliasedEnumOutputStream) => void;
  getImpl: (name: FnTestAliasedEnumOutputImplKey) => FnTestAliasedEnumOutputImpl;
}

function createFnTestAliasedEnumOutputInstance(): IFnTestAliasedEnumOutput & FnTestAliasedEnumOutputFunction {

  const registry: Record<FnTestAliasedEnumOutputImplKey, FnTestAliasedEnumOutputImpl> = {}

  const wrapper: FnTestAliasedEnumOutputFunction = {
    getImpl: (name: FnTestAliasedEnumOutputImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestAliasedEnumOutput with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestAliasedEnumOutputImplKey, cb: IFnTestAliasedEnumOutput, stream_cb: IFnTestAliasedEnumOutputStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestAliasedEnumOutput with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestAliasedEnumOutput",
          /* returnType */ "TestEnum",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestAliasedEnumOutput: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnTestAliasedEnumOutput & FnTestAliasedEnumOutputFunction;
}

const FnTestAliasedEnumOutput = createFnTestAliasedEnumOutputInstance();

// BAML function signature
type IFnTestClassAlias = (arg: string) => Promise<TestClassAlias>

// BAML function stream signature
type IFnTestClassAliasStream = (arg: string) => LLMResponseStream<TestClassAlias>

type FnTestClassAliasImplKey = 'v1';

interface FnTestClassAliasImpl {
    name: FnTestClassAliasImplKey;
    run: IFnTestClassAlias;
    stream: IFnTestClassAliasStream;
}

interface FnTestClassAliasFunction {
  stream: IFnTestClassAliasStream;
  registerImpl: (name: FnTestClassAliasImplKey, cb: IFnTestClassAlias, stream_cb: IFnTestClassAliasStream) => void;
  getImpl: (name: FnTestClassAliasImplKey) => FnTestClassAliasImpl;
}

function createFnTestClassAliasInstance(): IFnTestClassAlias & FnTestClassAliasFunction {

  const registry: Record<FnTestClassAliasImplKey, FnTestClassAliasImpl> = {}

  const wrapper: FnTestClassAliasFunction = {
    getImpl: (name: FnTestClassAliasImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestClassAlias with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestClassAliasImplKey, cb: IFnTestClassAlias, stream_cb: IFnTestClassAliasStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestClassAlias with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestClassAlias",
          /* returnType */ "TestClassAlias",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestClassAlias: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnTestClassAlias & FnTestClassAliasFunction;
}

const FnTestClassAlias = createFnTestClassAliasInstance();

// BAML function signature
type IFnTestClassOverride = (arg: string) => Promise<OverrideClass>

// BAML function stream signature
type IFnTestClassOverrideStream = (arg: string) => LLMResponseStream<OverrideClass>

type FnTestClassOverrideImplKey = 'v1';

interface FnTestClassOverrideImpl {
    name: FnTestClassOverrideImplKey;
    run: IFnTestClassOverride;
    stream: IFnTestClassOverrideStream;
}

interface FnTestClassOverrideFunction {
  stream: IFnTestClassOverrideStream;
  registerImpl: (name: FnTestClassOverrideImplKey, cb: IFnTestClassOverride, stream_cb: IFnTestClassOverrideStream) => void;
  getImpl: (name: FnTestClassOverrideImplKey) => FnTestClassOverrideImpl;
}

function createFnTestClassOverrideInstance(): IFnTestClassOverride & FnTestClassOverrideFunction {

  const registry: Record<FnTestClassOverrideImplKey, FnTestClassOverrideImpl> = {}

  const wrapper: FnTestClassOverrideFunction = {
    getImpl: (name: FnTestClassOverrideImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestClassOverride with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestClassOverrideImplKey, cb: IFnTestClassOverride, stream_cb: IFnTestClassOverrideStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestClassOverride with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestClassOverride",
          /* returnType */ "OverrideClass",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestClassOverride: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnTestClassOverride & FnTestClassOverrideFunction;
}

const FnTestClassOverride = createFnTestClassOverrideInstance();

// BAML function signature
type IFnTestEnumOverride = (arg: string) => Promise<OverrideEnum>

// BAML function stream signature
type IFnTestEnumOverrideStream = (arg: string) => LLMResponseStream<OverrideEnum>

type FnTestEnumOverrideImplKey = 'v1';

interface FnTestEnumOverrideImpl {
    name: FnTestEnumOverrideImplKey;
    run: IFnTestEnumOverride;
    stream: IFnTestEnumOverrideStream;
}

interface FnTestEnumOverrideFunction {
  stream: IFnTestEnumOverrideStream;
  registerImpl: (name: FnTestEnumOverrideImplKey, cb: IFnTestEnumOverride, stream_cb: IFnTestEnumOverrideStream) => void;
  getImpl: (name: FnTestEnumOverrideImplKey) => FnTestEnumOverrideImpl;
}

function createFnTestEnumOverrideInstance(): IFnTestEnumOverride & FnTestEnumOverrideFunction {

  const registry: Record<FnTestEnumOverrideImplKey, FnTestEnumOverrideImpl> = {}

  const wrapper: FnTestEnumOverrideFunction = {
    getImpl: (name: FnTestEnumOverrideImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestEnumOverride with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestEnumOverrideImplKey, cb: IFnTestEnumOverride, stream_cb: IFnTestEnumOverrideStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestEnumOverride with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestEnumOverride",
          /* returnType */ "OverrideEnum",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestEnumOverride: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnTestEnumOverride & FnTestEnumOverrideFunction;
}

const FnTestEnumOverride = createFnTestEnumOverrideInstance();

// BAML function signature
type IFnTestNamedArgsSingleEnum = (args: {
  myArg: NamedArgsSingleEnum, 
}) => Promise<string>

// BAML function stream signature
type IFnTestNamedArgsSingleEnumStream = (args: {
  myArg: NamedArgsSingleEnum, 
}) => Promise<string>

type FnTestNamedArgsSingleEnumImplKey = 'v1';

interface FnTestNamedArgsSingleEnumImpl {
    name: FnTestNamedArgsSingleEnumImplKey;
    run: IFnTestNamedArgsSingleEnum;
    stream: IFnTestNamedArgsSingleEnumStream;
}

interface FnTestNamedArgsSingleEnumFunction {
  stream: IFnTestNamedArgsSingleEnumStream;
  registerImpl: (name: FnTestNamedArgsSingleEnumImplKey, cb: IFnTestNamedArgsSingleEnum, stream_cb: IFnTestNamedArgsSingleEnumStream) => void;
  getImpl: (name: FnTestNamedArgsSingleEnumImplKey) => FnTestNamedArgsSingleEnumImpl;
}

function createFnTestNamedArgsSingleEnumInstance(): IFnTestNamedArgsSingleEnum & FnTestNamedArgsSingleEnumFunction {

  const registry: Record<FnTestNamedArgsSingleEnumImplKey, FnTestNamedArgsSingleEnumImpl> = {}

  const wrapper: FnTestNamedArgsSingleEnumFunction = {
    getImpl: (name: FnTestNamedArgsSingleEnumImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestNamedArgsSingleEnum with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestNamedArgsSingleEnumImplKey, cb: IFnTestNamedArgsSingleEnum, stream_cb: IFnTestNamedArgsSingleEnumStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestNamedArgsSingleEnum with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestNamedArgsSingleEnum",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleEnum"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleEnum
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestNamedArgsSingleEnum: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleEnum
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as IFnTestNamedArgsSingleEnum & FnTestNamedArgsSingleEnumFunction;
}

const FnTestNamedArgsSingleEnum = createFnTestNamedArgsSingleEnumInstance();

// BAML function signature
type IFnTestOutputAdapter = (arg: string) => Promise<string>

// BAML function stream signature
type IFnTestOutputAdapterStream = (arg: string) => LLMResponseStream<string>

type FnTestOutputAdapterImplKey = 'v1';

interface FnTestOutputAdapterImpl {
    name: FnTestOutputAdapterImplKey;
    run: IFnTestOutputAdapter;
    stream: IFnTestOutputAdapterStream;
}

interface FnTestOutputAdapterFunction {
  stream: IFnTestOutputAdapterStream;
  registerImpl: (name: FnTestOutputAdapterImplKey, cb: IFnTestOutputAdapter, stream_cb: IFnTestOutputAdapterStream) => void;
  getImpl: (name: FnTestOutputAdapterImplKey) => FnTestOutputAdapterImpl;
}

function createFnTestOutputAdapterInstance(): IFnTestOutputAdapter & FnTestOutputAdapterFunction {

  const registry: Record<FnTestOutputAdapterImplKey, FnTestOutputAdapterImpl> = {}

  const wrapper: FnTestOutputAdapterFunction = {
    getImpl: (name: FnTestOutputAdapterImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for FnTestOutputAdapter with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: FnTestOutputAdapterImplKey, cb: IFnTestOutputAdapter, stream_cb: IFnTestOutputAdapterStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for FnTestOutputAdapter with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"FnTestOutputAdapter",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for FnTestOutputAdapter: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IFnTestOutputAdapter & FnTestOutputAdapterFunction;
}

const FnTestOutputAdapter = createFnTestOutputAdapterInstance();

// BAML function signature
type IOptionalTest_Function = (arg: string) => Promise<OptionalTest_ReturnType | null[]>

// BAML function stream signature
type IOptionalTest_FunctionStream = (arg: string) => LLMResponseStream<OptionalTest_ReturnType | null[]>

type OptionalTest_FunctionImplKey = 'v1';

interface OptionalTest_FunctionImpl {
    name: OptionalTest_FunctionImplKey;
    run: IOptionalTest_Function;
    stream: IOptionalTest_FunctionStream;
}

interface OptionalTest_FunctionFunction {
  stream: IOptionalTest_FunctionStream;
  registerImpl: (name: OptionalTest_FunctionImplKey, cb: IOptionalTest_Function, stream_cb: IOptionalTest_FunctionStream) => void;
  getImpl: (name: OptionalTest_FunctionImplKey) => OptionalTest_FunctionImpl;
}

function createOptionalTest_FunctionInstance(): IOptionalTest_Function & OptionalTest_FunctionFunction {

  const registry: Record<OptionalTest_FunctionImplKey, OptionalTest_FunctionImpl> = {}

  const wrapper: OptionalTest_FunctionFunction = {
    getImpl: (name: OptionalTest_FunctionImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for OptionalTest_Function with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: OptionalTest_FunctionImplKey, cb: IOptionalTest_Function, stream_cb: IOptionalTest_FunctionStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for OptionalTest_Function with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"OptionalTest_Function",
          /* returnType */ "OptionalTest_ReturnType | null[]",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for OptionalTest_Function: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IOptionalTest_Function & OptionalTest_FunctionFunction;
}

const OptionalTest_Function = createOptionalTest_FunctionInstance();

// BAML function signature
type IPromptTest = (arg: string) => Promise<string>

// BAML function stream signature
type IPromptTestStream = (arg: string) => LLMResponseStream<string>

type PromptTestImplKey = 'bird_chat' | 'claude_chat' | 'claude_chat_with_chat_msgs' | 'claude_chat_with_chat_msgs_no_system' | 'openai_chat' | 'openai_chat_with_chat_msgs' | 'openai_chat_with_chat_msgs_no_system';

interface PromptTestImpl {
    name: PromptTestImplKey;
    run: IPromptTest;
    stream: IPromptTestStream;
}

interface PromptTestFunction {
  stream: IPromptTestStream;
  registerImpl: (name: PromptTestImplKey, cb: IPromptTest, stream_cb: IPromptTestStream) => void;
  getImpl: (name: PromptTestImplKey) => PromptTestImpl;
}

function createPromptTestInstance(): IPromptTest & PromptTestFunction {

  const registry: Record<PromptTestImplKey, PromptTestImpl> = {}

  const wrapper: PromptTestFunction = {
    getImpl: (name: PromptTestImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for PromptTest with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: PromptTestImplKey, cb: IPromptTest, stream_cb: IPromptTestStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for PromptTest with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"PromptTest",
          /* returnType */ "string",
          /* paramters */ [
            [
              "arg",
              "string"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['bird_chat', 'claude_chat', 'claude_chat_with_chat_msgs', 'claude_chat_with_chat_msgs_no_system', 'openai_chat', 'openai_chat_with_chat_msgs', 'openai_chat_with_chat_msgs_no_system'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for PromptTest: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string) => {
    return wrapper.getImpl('claude_chat').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('claude_chat').stream(arg);
    }
  })

  return impl as IPromptTest & PromptTestFunction;
}

const PromptTest = createPromptTestInstance();

// BAML function signature
type ITestFnNamedArgsSingleBool = (args: {
  myBool: boolean, 
}) => Promise<string>

// BAML function stream signature
type ITestFnNamedArgsSingleBoolStream = (args: {
  myBool: boolean, 
}) => Promise<string>

type TestFnNamedArgsSingleBoolImplKey = 'v1';

interface TestFnNamedArgsSingleBoolImpl {
    name: TestFnNamedArgsSingleBoolImplKey;
    run: ITestFnNamedArgsSingleBool;
    stream: ITestFnNamedArgsSingleBoolStream;
}

interface TestFnNamedArgsSingleBoolFunction {
  stream: ITestFnNamedArgsSingleBoolStream;
  registerImpl: (name: TestFnNamedArgsSingleBoolImplKey, cb: ITestFnNamedArgsSingleBool, stream_cb: ITestFnNamedArgsSingleBoolStream) => void;
  getImpl: (name: TestFnNamedArgsSingleBoolImplKey) => TestFnNamedArgsSingleBoolImpl;
}

function createTestFnNamedArgsSingleBoolInstance(): ITestFnNamedArgsSingleBool & TestFnNamedArgsSingleBoolFunction {

  const registry: Record<TestFnNamedArgsSingleBoolImplKey, TestFnNamedArgsSingleBoolImpl> = {}

  const wrapper: TestFnNamedArgsSingleBoolFunction = {
    getImpl: (name: TestFnNamedArgsSingleBoolImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleBool with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleBoolImplKey, cb: ITestFnNamedArgsSingleBool, stream_cb: ITestFnNamedArgsSingleBoolStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleBool with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleBool",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myBool",
              "boolean"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myBool: boolean
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleBool: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myBool: boolean
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as ITestFnNamedArgsSingleBool & TestFnNamedArgsSingleBoolFunction;
}

const TestFnNamedArgsSingleBool = createTestFnNamedArgsSingleBoolInstance();

// BAML function signature
type ITestFnNamedArgsSingleClass = (args: {
  myArg: NamedArgsSingleClass, 
}) => Promise<string>

// BAML function stream signature
type ITestFnNamedArgsSingleClassStream = (args: {
  myArg: NamedArgsSingleClass, 
}) => Promise<string>

type TestFnNamedArgsSingleClassImplKey = 'v1';

interface TestFnNamedArgsSingleClassImpl {
    name: TestFnNamedArgsSingleClassImplKey;
    run: ITestFnNamedArgsSingleClass;
    stream: ITestFnNamedArgsSingleClassStream;
}

interface TestFnNamedArgsSingleClassFunction {
  stream: ITestFnNamedArgsSingleClassStream;
  registerImpl: (name: TestFnNamedArgsSingleClassImplKey, cb: ITestFnNamedArgsSingleClass, stream_cb: ITestFnNamedArgsSingleClassStream) => void;
  getImpl: (name: TestFnNamedArgsSingleClassImplKey) => TestFnNamedArgsSingleClassImpl;
}

function createTestFnNamedArgsSingleClassInstance(): ITestFnNamedArgsSingleClass & TestFnNamedArgsSingleClassFunction {

  const registry: Record<TestFnNamedArgsSingleClassImplKey, TestFnNamedArgsSingleClassImpl> = {}

  const wrapper: TestFnNamedArgsSingleClassFunction = {
    getImpl: (name: TestFnNamedArgsSingleClassImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleClass with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleClassImplKey, cb: ITestFnNamedArgsSingleClass, stream_cb: ITestFnNamedArgsSingleClassStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleClass with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleClass",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleClass"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleClass
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleClass: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleClass
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as ITestFnNamedArgsSingleClass & TestFnNamedArgsSingleClassFunction;
}

const TestFnNamedArgsSingleClass = createTestFnNamedArgsSingleClassInstance();

// BAML function signature
type ITestFnNamedArgsSingleEnumList = (args: {
  myArg: NamedArgsSingleEnumList[], 
}) => Promise<string>

// BAML function stream signature
type ITestFnNamedArgsSingleEnumListStream = (args: {
  myArg: NamedArgsSingleEnumList[], 
}) => Promise<string>

type TestFnNamedArgsSingleEnumListImplKey = 'v1';

interface TestFnNamedArgsSingleEnumListImpl {
    name: TestFnNamedArgsSingleEnumListImplKey;
    run: ITestFnNamedArgsSingleEnumList;
    stream: ITestFnNamedArgsSingleEnumListStream;
}

interface TestFnNamedArgsSingleEnumListFunction {
  stream: ITestFnNamedArgsSingleEnumListStream;
  registerImpl: (name: TestFnNamedArgsSingleEnumListImplKey, cb: ITestFnNamedArgsSingleEnumList, stream_cb: ITestFnNamedArgsSingleEnumListStream) => void;
  getImpl: (name: TestFnNamedArgsSingleEnumListImplKey) => TestFnNamedArgsSingleEnumListImpl;
}

function createTestFnNamedArgsSingleEnumListInstance(): ITestFnNamedArgsSingleEnumList & TestFnNamedArgsSingleEnumListFunction {

  const registry: Record<TestFnNamedArgsSingleEnumListImplKey, TestFnNamedArgsSingleEnumListImpl> = {}

  const wrapper: TestFnNamedArgsSingleEnumListFunction = {
    getImpl: (name: TestFnNamedArgsSingleEnumListImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleEnumList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleEnumListImplKey, cb: ITestFnNamedArgsSingleEnumList, stream_cb: ITestFnNamedArgsSingleEnumListStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleEnumList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleEnumList",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "NamedArgsSingleEnumList[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: NamedArgsSingleEnumList[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleEnumList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: NamedArgsSingleEnumList[]
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as ITestFnNamedArgsSingleEnumList & TestFnNamedArgsSingleEnumListFunction;
}

const TestFnNamedArgsSingleEnumList = createTestFnNamedArgsSingleEnumListInstance();

// BAML function signature
type ITestFnNamedArgsSingleFloat = (args: {
  myFloat: number, 
}) => Promise<string>

// BAML function stream signature
type ITestFnNamedArgsSingleFloatStream = (args: {
  myFloat: number, 
}) => Promise<string>

type TestFnNamedArgsSingleFloatImplKey = 'v1';

interface TestFnNamedArgsSingleFloatImpl {
    name: TestFnNamedArgsSingleFloatImplKey;
    run: ITestFnNamedArgsSingleFloat;
    stream: ITestFnNamedArgsSingleFloatStream;
}

interface TestFnNamedArgsSingleFloatFunction {
  stream: ITestFnNamedArgsSingleFloatStream;
  registerImpl: (name: TestFnNamedArgsSingleFloatImplKey, cb: ITestFnNamedArgsSingleFloat, stream_cb: ITestFnNamedArgsSingleFloatStream) => void;
  getImpl: (name: TestFnNamedArgsSingleFloatImplKey) => TestFnNamedArgsSingleFloatImpl;
}

function createTestFnNamedArgsSingleFloatInstance(): ITestFnNamedArgsSingleFloat & TestFnNamedArgsSingleFloatFunction {

  const registry: Record<TestFnNamedArgsSingleFloatImplKey, TestFnNamedArgsSingleFloatImpl> = {}

  const wrapper: TestFnNamedArgsSingleFloatFunction = {
    getImpl: (name: TestFnNamedArgsSingleFloatImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleFloat with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleFloatImplKey, cb: ITestFnNamedArgsSingleFloat, stream_cb: ITestFnNamedArgsSingleFloatStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleFloat with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleFloat",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myFloat",
              "number"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myFloat: number
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleFloat: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myFloat: number
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as ITestFnNamedArgsSingleFloat & TestFnNamedArgsSingleFloatFunction;
}

const TestFnNamedArgsSingleFloat = createTestFnNamedArgsSingleFloatInstance();

// BAML function signature
type ITestFnNamedArgsSingleInt = (args: {
  myInt: number, 
}) => Promise<string>

// BAML function stream signature
type ITestFnNamedArgsSingleIntStream = (args: {
  myInt: number, 
}) => Promise<string>

type TestFnNamedArgsSingleIntImplKey = 'v1';

interface TestFnNamedArgsSingleIntImpl {
    name: TestFnNamedArgsSingleIntImplKey;
    run: ITestFnNamedArgsSingleInt;
    stream: ITestFnNamedArgsSingleIntStream;
}

interface TestFnNamedArgsSingleIntFunction {
  stream: ITestFnNamedArgsSingleIntStream;
  registerImpl: (name: TestFnNamedArgsSingleIntImplKey, cb: ITestFnNamedArgsSingleInt, stream_cb: ITestFnNamedArgsSingleIntStream) => void;
  getImpl: (name: TestFnNamedArgsSingleIntImplKey) => TestFnNamedArgsSingleIntImpl;
}

function createTestFnNamedArgsSingleIntInstance(): ITestFnNamedArgsSingleInt & TestFnNamedArgsSingleIntFunction {

  const registry: Record<TestFnNamedArgsSingleIntImplKey, TestFnNamedArgsSingleIntImpl> = {}

  const wrapper: TestFnNamedArgsSingleIntFunction = {
    getImpl: (name: TestFnNamedArgsSingleIntImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleInt with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleIntImplKey, cb: ITestFnNamedArgsSingleInt, stream_cb: ITestFnNamedArgsSingleIntStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleInt with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleInt",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myInt",
              "number"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myInt: number
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleInt: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myInt: number
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as ITestFnNamedArgsSingleInt & TestFnNamedArgsSingleIntFunction;
}

const TestFnNamedArgsSingleInt = createTestFnNamedArgsSingleIntInstance();

// BAML function signature
type ITestFnNamedArgsSingleString = (args: {
  myString: string, 
}) => Promise<string>

// BAML function stream signature
type ITestFnNamedArgsSingleStringStream = (args: {
  myString: string, 
}) => Promise<string>

type TestFnNamedArgsSingleStringImplKey = 'v1';

interface TestFnNamedArgsSingleStringImpl {
    name: TestFnNamedArgsSingleStringImplKey;
    run: ITestFnNamedArgsSingleString;
    stream: ITestFnNamedArgsSingleStringStream;
}

interface TestFnNamedArgsSingleStringFunction {
  stream: ITestFnNamedArgsSingleStringStream;
  registerImpl: (name: TestFnNamedArgsSingleStringImplKey, cb: ITestFnNamedArgsSingleString, stream_cb: ITestFnNamedArgsSingleStringStream) => void;
  getImpl: (name: TestFnNamedArgsSingleStringImplKey) => TestFnNamedArgsSingleStringImpl;
}

function createTestFnNamedArgsSingleStringInstance(): ITestFnNamedArgsSingleString & TestFnNamedArgsSingleStringFunction {

  const registry: Record<TestFnNamedArgsSingleStringImplKey, TestFnNamedArgsSingleStringImpl> = {}

  const wrapper: TestFnNamedArgsSingleStringFunction = {
    getImpl: (name: TestFnNamedArgsSingleStringImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleString with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleStringImplKey, cb: ITestFnNamedArgsSingleString, stream_cb: ITestFnNamedArgsSingleStringStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleString with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleString",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myString",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myString: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleString: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myString: string
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as ITestFnNamedArgsSingleString & TestFnNamedArgsSingleStringFunction;
}

const TestFnNamedArgsSingleString = createTestFnNamedArgsSingleStringInstance();

// BAML function signature
type ITestFnNamedArgsSingleStringArray = (args: {
  myStringArray: string[], 
}) => Promise<string>

// BAML function stream signature
type ITestFnNamedArgsSingleStringArrayStream = (args: {
  myStringArray: string[], 
}) => Promise<string>

type TestFnNamedArgsSingleStringArrayImplKey = 'v1';

interface TestFnNamedArgsSingleStringArrayImpl {
    name: TestFnNamedArgsSingleStringArrayImplKey;
    run: ITestFnNamedArgsSingleStringArray;
    stream: ITestFnNamedArgsSingleStringArrayStream;
}

interface TestFnNamedArgsSingleStringArrayFunction {
  stream: ITestFnNamedArgsSingleStringArrayStream;
  registerImpl: (name: TestFnNamedArgsSingleStringArrayImplKey, cb: ITestFnNamedArgsSingleStringArray, stream_cb: ITestFnNamedArgsSingleStringArrayStream) => void;
  getImpl: (name: TestFnNamedArgsSingleStringArrayImplKey) => TestFnNamedArgsSingleStringArrayImpl;
}

function createTestFnNamedArgsSingleStringArrayInstance(): ITestFnNamedArgsSingleStringArray & TestFnNamedArgsSingleStringArrayFunction {

  const registry: Record<TestFnNamedArgsSingleStringArrayImplKey, TestFnNamedArgsSingleStringArrayImpl> = {}

  const wrapper: TestFnNamedArgsSingleStringArrayFunction = {
    getImpl: (name: TestFnNamedArgsSingleStringArrayImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleStringArray with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleStringArrayImplKey, cb: ITestFnNamedArgsSingleStringArray, stream_cb: ITestFnNamedArgsSingleStringArrayStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleStringArray with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleStringArray",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myStringArray",
              "string[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myStringArray: string[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleStringArray: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myStringArray: string[]
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as ITestFnNamedArgsSingleStringArray & TestFnNamedArgsSingleStringArrayFunction;
}

const TestFnNamedArgsSingleStringArray = createTestFnNamedArgsSingleStringArrayInstance();

// BAML function signature
type ITestFnNamedArgsSingleStringList = (args: {
  myArg: string[], 
}) => Promise<string>

// BAML function stream signature
type ITestFnNamedArgsSingleStringListStream = (args: {
  myArg: string[], 
}) => Promise<string>

type TestFnNamedArgsSingleStringListImplKey = 'v1';

interface TestFnNamedArgsSingleStringListImpl {
    name: TestFnNamedArgsSingleStringListImplKey;
    run: ITestFnNamedArgsSingleStringList;
    stream: ITestFnNamedArgsSingleStringListStream;
}

interface TestFnNamedArgsSingleStringListFunction {
  stream: ITestFnNamedArgsSingleStringListStream;
  registerImpl: (name: TestFnNamedArgsSingleStringListImplKey, cb: ITestFnNamedArgsSingleStringList, stream_cb: ITestFnNamedArgsSingleStringListStream) => void;
  getImpl: (name: TestFnNamedArgsSingleStringListImplKey) => TestFnNamedArgsSingleStringListImpl;
}

function createTestFnNamedArgsSingleStringListInstance(): ITestFnNamedArgsSingleStringList & TestFnNamedArgsSingleStringListFunction {

  const registry: Record<TestFnNamedArgsSingleStringListImplKey, TestFnNamedArgsSingleStringListImpl> = {}

  const wrapper: TestFnNamedArgsSingleStringListFunction = {
    getImpl: (name: TestFnNamedArgsSingleStringListImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSingleStringList with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSingleStringListImplKey, cb: ITestFnNamedArgsSingleStringList, stream_cb: ITestFnNamedArgsSingleStringListStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSingleStringList with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSingleStringList",
          /* returnType */ "string",
          /* paramters */ [
            [
              "myArg",
              "string[]"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            myArg: string[]
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for TestFnNamedArgsSingleStringList: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (params : {
    myArg: string[]
  }) => {
    return wrapper.getImpl('v1').run(params);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      return wrapper.getImpl('v1').stream(params);
    }
  })

  return impl as ITestFnNamedArgsSingleStringList & TestFnNamedArgsSingleStringListFunction;
}

const TestFnNamedArgsSingleStringList = createTestFnNamedArgsSingleStringListInstance();

// BAML function signature
type ITestFnNamedArgsSyntax = (args: {
  var: string, var_with_underscores: string, 
}) => Promise<string>

// BAML function stream signature
type ITestFnNamedArgsSyntaxStream = (args: {
  var: string, var_with_underscores: string, 
}) => Promise<string>

type TestFnNamedArgsSyntaxImplKey = never;

interface TestFnNamedArgsSyntaxImpl {
    name: TestFnNamedArgsSyntaxImplKey;
    run: ITestFnNamedArgsSyntax;
    stream: ITestFnNamedArgsSyntaxStream;
}

interface TestFnNamedArgsSyntaxFunction {
  stream: ITestFnNamedArgsSyntaxStream;
  registerImpl: (name: TestFnNamedArgsSyntaxImplKey, cb: ITestFnNamedArgsSyntax, stream_cb: ITestFnNamedArgsSyntaxStream) => void;
  getImpl: (name: TestFnNamedArgsSyntaxImplKey) => TestFnNamedArgsSyntaxImpl;
}

function createTestFnNamedArgsSyntaxInstance(): ITestFnNamedArgsSyntax & TestFnNamedArgsSyntaxFunction {

  const registry: Record<TestFnNamedArgsSyntaxImplKey, TestFnNamedArgsSyntaxImpl> = {}

  const wrapper: TestFnNamedArgsSyntaxFunction = {
    getImpl: (name: TestFnNamedArgsSyntaxImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for TestFnNamedArgsSyntax with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: TestFnNamedArgsSyntaxImplKey, cb: ITestFnNamedArgsSyntax, stream_cb: ITestFnNamedArgsSyntaxStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for TestFnNamedArgsSyntax with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"TestFnNamedArgsSyntax",
          /* returnType */ "string",
          /* paramters */ [
            [
              "var",
              "string"
            ],
            [
              "var_with_underscores",
              "string"
            ]
          ],
          /* arg_type */ 'named',
          /* cb */ async (
          params: {
            var: string, var_with_underscores: string
          }
        ) => {
          FireBamlEvent.variant(name);
          return await cb(params);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
    }
  };

  const impl = async (params : {
    var: string, var_with_underscores: string
  }) => {
    throw new Error('No implementation for TestFnNamedArgsSyntax');
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (params) => {
      throw new Error('No implementation for TestFnNamedArgsSyntax');
    }
  })

  return impl as ITestFnNamedArgsSyntax & TestFnNamedArgsSyntaxFunction;
}

const TestFnNamedArgsSyntax = createTestFnNamedArgsSyntaxInstance();

// BAML function signature
type IUnionTest_Function = (arg: string | boolean) => Promise<UnionTest_ReturnType>

// BAML function stream signature
type IUnionTest_FunctionStream = (arg: string | boolean) => LLMResponseStream<UnionTest_ReturnType>

type UnionTest_FunctionImplKey = 'v1';

interface UnionTest_FunctionImpl {
    name: UnionTest_FunctionImplKey;
    run: IUnionTest_Function;
    stream: IUnionTest_FunctionStream;
}

interface UnionTest_FunctionFunction {
  stream: IUnionTest_FunctionStream;
  registerImpl: (name: UnionTest_FunctionImplKey, cb: IUnionTest_Function, stream_cb: IUnionTest_FunctionStream) => void;
  getImpl: (name: UnionTest_FunctionImplKey) => UnionTest_FunctionImpl;
}

function createUnionTest_FunctionInstance(): IUnionTest_Function & UnionTest_FunctionFunction {

  const registry: Record<UnionTest_FunctionImplKey, UnionTest_FunctionImpl> = {}

  const wrapper: UnionTest_FunctionFunction = {
    getImpl: (name: UnionTest_FunctionImplKey) => {
      const impl = registry[name];
      if (!impl) {
        throw new Error(`No implementation for UnionTest_Function with name ${name}`);
      }
      return impl;
    },
    registerImpl: (name: UnionTest_FunctionImplKey, cb: IUnionTest_Function, stream_cb: IUnionTest_FunctionStream) => {
      if (registry[name]) {
        throw new Error(`Implementation for UnionTest_Function with name ${name} already exists`);
      }
      registry[name] = {
        name,
        run: traceAsync(
          /* functionName */"UnionTest_Function",
          /* returnType */ "UnionTest_ReturnType",
          /* paramters */ [
            [
              "arg",
              "string | boolean"
            ]
          ],
          /* arg_type */ 'positional',
          /* cb */ async (
          arg: string | boolean
        ) => {
          FireBamlEvent.variant(name);
          return await cb(arg);
        }),
        stream: stream_cb,
      };
    },
    validate: () => {
      const targets = ['v1'];
      const impls = Object.keys(registry);
      const missing = targets.filter(t => !impls.includes(t));
      if (missing.length > 0) {
        throw new Error(`Missing implementations for UnionTest_Function: ${missing.join(', ')}`);
      }
    }
  };

  const impl = async (arg: string | boolean) => {
    return wrapper.getImpl('v1').run(arg);
  };

  Object.assign(impl, wrapper);
  Object.assign(impl, {
    stream: (arg) => {
      return wrapper.getImpl('v1').stream(arg);
    }
  })

  return impl as IUnionTest_Function & UnionTest_FunctionFunction;
}

const UnionTest_Function = createUnionTest_FunctionInstance();


export { FnClassOptional, IFnClassOptional, FnClassOptionalFunction, FnClassOptional2, IFnClassOptional2, FnClassOptional2Function, FnClassOptionalOutput, IFnClassOptionalOutput, FnClassOptionalOutputFunction, FnClassOptionalOutput2, IFnClassOptionalOutput2, FnClassOptionalOutput2Function, FnEnumListOutput, IFnEnumListOutput, FnEnumListOutputFunction, FnEnumOutput, IFnEnumOutput, FnEnumOutputFunction, FnNamedArgsSingleStringOptional, IFnNamedArgsSingleStringOptional, FnNamedArgsSingleStringOptionalFunction, FnOutputBool, IFnOutputBool, FnOutputBoolFunction, FnOutputClass, IFnOutputClass, FnOutputClassFunction, FnOutputClassList, IFnOutputClassList, FnOutputClassListFunction, FnOutputClassWithEnum, IFnOutputClassWithEnum, FnOutputClassWithEnumFunction, FnOutputStringList, IFnOutputStringList, FnOutputStringListFunction, FnStringOptional, IFnStringOptional, FnStringOptionalFunction, FnTestAliasedEnumOutput, IFnTestAliasedEnumOutput, FnTestAliasedEnumOutputFunction, FnTestClassAlias, IFnTestClassAlias, FnTestClassAliasFunction, FnTestClassOverride, IFnTestClassOverride, FnTestClassOverrideFunction, FnTestEnumOverride, IFnTestEnumOverride, FnTestEnumOverrideFunction, FnTestNamedArgsSingleEnum, IFnTestNamedArgsSingleEnum, FnTestNamedArgsSingleEnumFunction, FnTestOutputAdapter, IFnTestOutputAdapter, FnTestOutputAdapterFunction, OptionalTest_Function, IOptionalTest_Function, OptionalTest_FunctionFunction, PromptTest, IPromptTest, PromptTestFunction, TestFnNamedArgsSingleBool, ITestFnNamedArgsSingleBool, TestFnNamedArgsSingleBoolFunction, TestFnNamedArgsSingleClass, ITestFnNamedArgsSingleClass, TestFnNamedArgsSingleClassFunction, TestFnNamedArgsSingleEnumList, ITestFnNamedArgsSingleEnumList, TestFnNamedArgsSingleEnumListFunction, TestFnNamedArgsSingleFloat, ITestFnNamedArgsSingleFloat, TestFnNamedArgsSingleFloatFunction, TestFnNamedArgsSingleInt, ITestFnNamedArgsSingleInt, TestFnNamedArgsSingleIntFunction, TestFnNamedArgsSingleString, ITestFnNamedArgsSingleString, TestFnNamedArgsSingleStringFunction, TestFnNamedArgsSingleStringArray, ITestFnNamedArgsSingleStringArray, TestFnNamedArgsSingleStringArrayFunction, TestFnNamedArgsSingleStringList, ITestFnNamedArgsSingleStringList, TestFnNamedArgsSingleStringListFunction, TestFnNamedArgsSyntax, ITestFnNamedArgsSyntax, TestFnNamedArgsSyntaxFunction, UnionTest_Function, IUnionTest_Function, UnionTest_FunctionFunction }

