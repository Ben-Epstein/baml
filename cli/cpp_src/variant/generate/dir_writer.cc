#include "variant/generate/dir_writer.h"

#include <fstream>
#include <iostream>
#include <map>
#include <regex>
#include <set>
#include <sstream>
#include <string>

namespace gloo {

const std::string PY_PREAMBLE = R"(
# This file is autogenerated by the gloo compiler
# Do not edit this file directly
# (skip unused imports)
# ruff: noqa: F401
# flake8: noqa
# pylint: skip-file
# isort: skip_file
)";

std::unique_ptr<std::stringstream> FileWriter::stream() {
  return std::unique_ptr<BufferStream>(new BufferStream(this));
}

void PyFileWriter::flush(const std::filesystem::path &_path) {
  // Sort imports
  std::sort(imports.begin(), imports.end());

  std::filesystem::path path =
      std::filesystem::weakly_canonical(_path).make_preferred();
  // Ensure directory exists
  std::filesystem::create_directories(path.parent_path());

  std::ofstream file(path, std::ios::out);
  file << PY_PREAMBLE;
  // Write imports first.
  for (const auto &[import_path, import_name, export_v] : imports) {
    file << "from " << import_path << " import " << import_name << std::endl;
  }
  file << std::endl;

  // Replace the template with the correct values using a regex
  for (const auto &[key, value] : template_vars) {
    size_t pos = 0;
    std::string to_replace = "{@@" + key + "}";
    while ((pos = content.find(to_replace, pos)) != std::string::npos) {
      content.replace(pos, to_replace.length(), value);
      pos += value.length();
    }
  }

  // Check if there are any template variables left
  std::smatch match;
  std::regex pattern("\\{@@[a-zA-Z0-9_]+\\}");
  std::string::const_iterator searchStart(content.cbegin());
  while (std::regex_search(searchStart, content.cend(), match, pattern)) {
    std::cerr << path << ": Template variable not replaced: " << match[0]
              << std::endl;
    searchStart = match.suffix().first;
  }
  if (std::regex_search(content, pattern)) {
    throw std::runtime_error(path.string() +
                             ": Template variable not replaced");
  }

  file << content;

  // Add __all__ if there are any exports
  if (std::any_of(imports.begin(), imports.end(),
                  [](const auto &import) { return std::get<2>(import); })) {
    file << std::endl;
    file << "__all__ = [" << std::endl;
    for (const auto &[import_path, import_name, export_v] : imports) {
      if (export_v) {
        file << "    '" << import_name << "'," << std::endl;
      }
    }
    file << "]" << std::endl;
  }
  std::cout << "Wrote to " << path << std::endl;
}

}  // namespace gloo